\documentclass[12pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{amsmath}

% Configuration de la page
\geometry{margin=2.5cm}
\pagestyle{fancy}
\fancyhf{}
\rhead{Shooter Spatial}
\lhead{Projet Paradigmes de Programmation}
\rfoot{\thepage}

% Configuration des listings de code
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    captionpos=b
}

% Configuration des liens
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=cyan
}

\begin{document}

% Page de titre personnalis√©e
\begin{titlepage}
    \centering
    
    \vspace*{2cm}
    
    % Titre principal
    {\Huge\bfseries Shooter Spatial\par}
    
    \vspace{0.5cm}
    {\large \texttt{üöÄ ‚≠ê üõ∏}\par}
    
    \vspace{1.5cm}
    
    % Ligne d√©corative
    \rule{\textwidth}{1pt}
    
    \vspace{1cm}
    
    % Sous-titre
    {\Large\bfseries Projet de Paradigmes de Programmation\par}
    
    \vspace{0.5cm}
    
    {\large Licence Informatique\par}
    
    \vspace{1cm}
    
    % Ligne d√©corative
    \rule{\textwidth}{1pt}
    
    \vfill
    
    % Description
    {\large 
    \begin{tabular}{rl}
        \textbf{Paradigmes :} & Orient√© Objet, Proc√©dural, √âv√©nementiel, Concurrent \\[0.3cm]
        \textbf{Langage :} & Python 3.7+ \\[0.3cm]
        \textbf{Technologies :} & tkinter, threading, pygame, JSON, HTML/CSS \\
    \end{tabular}
    \par}
    
    \vfill
    
    % Auteur
    {\large\textbf{R√©alis√© par}\par}
    \vspace{0.3cm}
    {\Large Valentin Lesnes\par}
    
    \vspace{2cm}
    
\end{titlepage}
\newpage

\tableofcontents
\newpage

\section{Introduction}

\subsection{Contexte du projet}

Ce projet s'inscrit dans le cadre du cours de Paradigmes de Programmation en Licence Informatique. L'objectif est de d√©velopper un mini-jeu complet int√©grant plusieurs paradigmes de programmation : proc√©dural, orient√© objet, √©v√©nementiel et concurrent. Tout en incluant une documentation compl√®te.

\subsection{Choix du jeu : Shooter Spatial}

Le jeu choisi est un \textbf{shooter spatial en 2D} de type arcade. Le joueur contr√¥le un vaisseau spatial qui doit d√©truire des ennemis (ast√©ro√Ødes) descendant vers lui. Ce type de jeu, inspir√© des classiques comme Space Invaders, permet d'illustrer efficacement tous les paradigmes requis.

\subsection{Objectifs p√©dagogiques}

\begin{itemize}
    \item Ma√Ætriser la programmation orient√©e objet (POO) avec h√©ritage et polymorphisme
    \item Impl√©menter une logique proc√©durale pour la boucle de jeu
    \item G√©rer les √©v√©nements utilisateur (clavier, souris) dans une interface graphique
    \item Utiliser la programmation concurrente avec des threads
    \item Sauvegarder et charger des donn√©es persistantes (scores)
    \item Cr√©er une interface web pour visualiser les scores
\end{itemize}

\section{Description du Gameplay}

\subsection{R√®gles du jeu}

\paragraph{Objectif principal}
Le joueur doit d√©truire un maximum d'ennemis pour accumuler des points. La partie se termine quand le joueur perd tous ces points de vie (ennemi atteint le bas de l'√©cran = - 1 vie).

\paragraph{M√©caniques de jeu}
\begin{itemize}
    \item \textbf{D√©placement} : Le vaisseau peut se d√©placer dans les 4 directions (gauche/droite/haut/bas)
    \item \textbf{Tir} : Le joueur peut tirer des projectiles vers le haut avec cooldown
    \item \textbf{Ennemis} : Des ennemis apparaissent p√©riodiquement en haut et descendent
    \item \textbf{Collision} : Un projectile qui touche un ennemi les d√©truit tous les deux
    \item \textbf{Points} : Chaque ennemi d√©truit rapporte 10 points
    \item \textbf{Vies} : Le joueur dispose de 3 vies (extensible √† 5 avec bonus)
    \item \textbf{Bonus} : 5 types de bonus tombent al√©atoirement (vie, vitesse, tirs multiples)
    \item \textbf{Difficult√© progressive} : Vitesse et fr√©quence d'apparition augmentent
    \item \textbf{Invincibilit√©} : Courte p√©riode d'invincibilit√© apr√®s avoir perdu une vie
\end{itemize}

\subsection{Conditions de victoire et d√©faite}

\paragraph{Objectif}
Le jeu est un survival shooter : l'objectif est de survivre le plus longtemps possible et d'accumuler le maximum de points.

\paragraph{D√©faite}
\begin{itemize}
    \item Toutes les vies sont perdues (3 vies de d√©part)
    \item Un ennemi touche le vaisseau : -1 vie
    \item Un ennemi atteint le bas de l'√©cran : -1 vie
\end{itemize}

\paragraph{Syst√®me de vies et bonus}
\begin{itemize}
    \item \textbf{Vies de d√©part} : 3 vies
    \item \textbf{Maximum} : 5 vies (avec bonus)
    \item \textbf{Invincibilit√©} : Apr√®s perte d'une vie, 20 frames d'invincibilit√©
    \item \textbf{Bonus vie} : Collectables pour gagner une vie suppl√©mentaire
\end{itemize}

\section{Conception Logicielle}

\subsection{Architecture g√©n√©rale}

Le projet est structur√© en plusieurs modules Python pour respecter le principe de s√©paration des responsabilit√©s :

\begin{itemize}
    \item \texttt{game\_classes.py} : Classes du mod√®le de jeu (POO)
    \begin{itemize}
        \item ObjetVolant (classe abstraite)
        \item Vaisseau, Ennemi, Projectile, Bonus
        \item GameEngine (moteur de jeu)
    \end{itemize}
    \item \texttt{score\_manager.py} : Gestion des scores avec historique et statistiques
    \item \texttt{shooter\_console.py} : Version console avec support plein √©cran
    \item \texttt{shooter\_gui.py} : Version graphique avec menu et interface responsive
    \item \texttt{serveur\_web.py} : Serveur HTTP pour le leaderboard web
    \item \texttt{index.html} : Page web du leaderboard (g√©n√©r√©e par score\_manager)
\end{itemize}

\subsection{Diagramme de classes}

Le fichier \textbf{Shooter\_Spatial\_Classes\_converted.pdf} pr√©sente le diagramme de classes UML du projet. On observe une hi√©rarchie d'h√©ritage claire avec la classe abstraite \texttt{ObjetVolant} dont h√©ritent \texttt{Vaisseau}, \texttt{Ennemi} et \texttt{Projectile}.

\subsection{Classes principales}

\subsubsection{ObjetVolant (classe abstraite)}

Classe de base pour tous les objets du jeu poss√©dant une position et pouvant entrer en collision.

\begin{lstlisting}[caption=Classe ObjetVolant]
class ObjetVolant:
    def __init__(self, x: int, y: int, largeur: int, hauteur: int):
        self.x = x
        self.y = y
        self.largeur = largeur
        self.hauteur = hauteur
        self.actif = True
    
    def deplacer(self, dx: int, dy: int):
        self.x += dx
        self.y += dy
    
    def collision_avec(self, autre: 'ObjetVolant') -> bool:
        return (self.x < autre.x + autre.largeur and
                self.x + self.largeur > autre.x and
                self.y < autre.y + autre.hauteur and
                self.y + self.hauteur > autre.y)
\end{lstlisting}

\subsubsection{Vaisseau}

Repr√©sente le vaisseau du joueur avec syst√®me de vies, bonus et tirs multiples.

\textbf{Attributs principaux :}
\begin{itemize}
    \item \texttt{vies} : Nombre de vies (3 √† 5)
    \item \texttt{invincible\_jusqu\_a} : Frame jusqu'√† laquelle le vaisseau est invincible
    \item \texttt{vitesse\_base} : Vitesse de d√©placement (adapt√©e √† la taille d'√©cran)
    \item \texttt{vitesse\_bonus} : Multiplicateur de vitesse (1.0 ou 1.5)
    \item \texttt{tir\_double}, \texttt{tir\_triple} : Modes de tir sp√©ciaux
    \item \texttt{bonus\_actif\_jusqu\_a} : Dict des bonus actifs avec leur dur√©e
\end{itemize}

\subsubsection{Ennemi}

Repr√©sente un ennemi avec vitesse variable et d√©placement progressif.

\textbf{Particularit√© :} Utilise \texttt{deplacement\_fractionnaire} pour un mouvement fluide m√™me √† faible vitesse.

\subsubsection{Projectile}

Repr√©sente un tir du joueur. Monte automatiquement √† vitesse fixe.

\subsubsection{Bonus}

Repr√©sente un bonus collectable avec 5 types diff√©rents :
\begin{itemize}
    \item \textbf{Vie (+)} : Ajoute une vie (max 5)
    \item \textbf{Vitesse (>>)} : Augmente vitesse de 50\% pendant 10 secondes
    \item \textbf{Tir double (=)} : Tire 2 projectiles simultan√©ment
    \item \textbf{Tir triple (‚â°)} : Tire 3 projectiles simultan√©ment
    \item \textbf{Tir rapide (!!!)} : R√©duit le cooldown de moiti√©
\end{itemize}

Chaque bonus a un poids de probabilit√© d'apparition diff√©rent.

\subsubsection{GameEngine}

Moteur de jeu principal qui coordonne toute la logique avec syst√®me de frames.

\textbf{Responsabilit√©s :}
\begin{itemize}
    \item Gestion des listes d'objets (ennemis, projectiles, bonus)
    \item D√©tection de collisions (projectile-ennemi, vaisseau-ennemi, vaisseau-bonus)
    \item Mise √† jour du score et √©tat du jeu
    \item Gestion de l'invincibilit√© temporaire
    \item V√©rification si un bonus peut √™tre ramass√© (pas de doublon)
    \item Syst√®me de frames pour le timing des √©v√©nements
\end{itemize}

\subsubsection{ScoreManager}

G√®re la persistance des scores avec historique et statistiques compl√®tes.

\textbf{Fonctionnalit√©s :}
\begin{itemize}
    \item Sauvegarde du meilleur score par joueur
    \item Historique des 10 derni√®res parties
    \item Statistiques : parties jou√©es, score moyen, score total
    \item Classement des meilleurs joueurs
    \item Export HTML du leaderboard pour affichage web
\end{itemize}

\section{Impl√©mentation des Paradigmes}

\subsection{Programmation Orient√©e Objet (POO)}

\paragraph{H√©ritage}
La hi√©rarchie de classes illustre l'h√©ritage : \texttt{Vaisseau}, \texttt{Ennemi}, \texttt{Projectile} et \texttt{Bonus} h√©ritent tous d'\texttt{ObjetVolant}, factorisant ainsi les attributs et m√©thodes communs (position, d√©placement, collision).

\paragraph{Encapsulation}
Chaque classe encapsule ses donn√©es et expose des m√©thodes publiques claires. Par exemple, \texttt{GameEngine} cache sa logique interne de v√©rification de collisions dans des m√©thodes priv√©es (\texttt{\_verifier\_collisions}, \texttt{\_peut\_ramasser\_bonus}).

\paragraph{Polymorphisme}
La m√©thode \texttt{collision\_avec()} peut √™tre appel√©e sur n'importe quel \texttt{ObjetVolant}, d√©montrant le polymorphisme. Tous les objets r√©pondent √† la m√™me interface commune.

\subsection{Syst√®me de Bonus}

Le syst√®me de bonus illustre la POO avec une classe d√©di√©e et un syst√®me de types :

\begin{lstlisting}[caption=Syst√®me de bonus avec probabilit√©s]
class Bonus(ObjetVolant):
    TYPES = {
        "vie": {"nom": "Vie +1", "couleur": "#ff00ff", 
                "icone": "+", "poids": 15},
        "vitesse": {"nom": "Vitesse", "couleur": "#00ffff", 
                    "icone": ">>", "poids": 25},
        "tir_double": {"nom": "Tir Double", "couleur": "#ffff00", 
                       "icone": "=", "poids": 25},
        "tir_triple": {"nom": "Tir Triple", "couleur": "#ff8800", 
                       "icone": "‚â°", "poids": 15},
        "tir_rapide": {"nom": "Tir Rapide", "couleur": "#ff0000", 
                       "icone": "!!!", "poids": 20},
    }
    
    def __init__(self, x, y):
        super().__init__(x, y, largeur=1, hauteur=1)
        # Selection aleatoire ponderee par les poids
        types_disponibles = list(self.TYPES.keys())
        poids = [self.TYPES[t]["poids"] for t in types_disponibles]
        self.type = random.choices(types_disponibles, 
                                   weights=poids, k=1)[0]
\end{lstlisting}

\paragraph{Gestion des bonus actifs}
Le vaisseau utilise un dictionnaire pour g√©rer les bonus temporaires :

\begin{lstlisting}[caption=Activation et expiration des bonus]
def activer_bonus(self, type_bonus, frame_actuelle, duree=300):
    if type_bonus == "vitesse":
        self.vitesse_bonus = 1.5
        self.bonus_actif_jusqu_a["vitesse"] = frame_actuelle + duree
    # ... autres bonus ...

def mettre_a_jour_bonus(self, frame_actuelle):
    bonus_a_retirer = []
    for type_bonus, frame_fin in self.bonus_actif_jusqu_a.items():
        if frame_actuelle >= frame_fin:
            bonus_a_retirer.append(type_bonus)
            # Desactiver le bonus
    for type_bonus in bonus_a_retirer:
        del self.bonus_actif_jusqu_a[type_bonus]
\end{lstlisting}

\subsection{Programmation Proc√©durale}

La version console utilise une approche proc√©durale dans sa boucle principale :

\begin{lstlisting}[caption=Boucle de jeu proc√©durale]
def boucle_jeu_procedurale(game_engine):
    while not game_engine.jeu_termine:
        # 1. Afficher l'√©tat
        afficher_grille(game_engine)
        
        # 2. Lire commande
        cmd = lire_commande()
        
        # 3. Traiter commande
        if cmd == 'q':
            game_engine.vaisseau.deplacer_gauche()
        elif cmd == 'd':
            game_engine.vaisseau.deplacer_droite()
        elif cmd == ' ':
            game_engine.tirer()
        
        # 4. Mettre √† jour
        game_engine.mettre_a_jour()
        
        # 5. V√©rifier victoire
        game_engine.verifier_victoire()
\end{lstlisting}

Cette approche s√©quentielle et lin√©aire est caract√©ristique du paradigme proc√©dural.

\subsection{Programmation √âv√©nementielle}

La version graphique avec \texttt{tkinter} utilise le paradigme √©v√©nementiel :

\begin{lstlisting}[caption=Gestion des √©v√©nements clavier]
class ShooterGUI:
    def __init__(self, root):
        # ...
        # Liaison des √©v√©nements
        self.root.bind('<Left>', self.deplacer_gauche)
        self.root.bind('<Right>', self.deplacer_droite)
        self.root.bind('<space>', self.tirer)
    
    def deplacer_gauche(self, event):
        """Callback d√©clench√© par l'√©v√©nement Left"""
        if self.jeu_en_cours:
            self.game_engine.vaisseau.deplacer_gauche()
    
    def tirer(self, event):
        """Callback d√©clench√© par l'√©v√©nement Space"""
        if self.jeu_en_cours:
            self.game_engine.tirer()
\end{lstlisting}

Les \textbf{timers} sont √©galement des m√©canismes √©v√©nementiels :

\begin{lstlisting}[caption=Timer pour mise √† jour p√©riodique]
def boucle_mise_a_jour(self):
    if not self.jeu_en_cours:
        return
    
    # Logique de mise √† jour
    self.game_engine.mettre_a_jour()
    self.dessiner()
    
    # Relancer le timer (√©v√©nement r√©current)
    self.timer_jeu = self.root.after(50, self.boucle_mise_a_jour)
\end{lstlisting}

\subsection{Programmation Concurrente (Threads)}

Trois threads s'ex√©cutent en parall√®le de la boucle principale pour am√©liorer l'exp√©rience de jeu :

\paragraph{Thread Musique}
Joue la musique de fond sans bloquer le jeu, avec support de pause/reprise :

\begin{lstlisting}[caption=Thread de musique avec pygame]
class MusiqueThread(threading.Thread):
    def __init__(self, fichier="musique.mp3"):
        super().__init__(daemon=True)
        self.actif = True
        self.en_pause = False
        pygame.mixer.init()
        pygame.mixer.music.load(fichier)
        pygame.mixer.music.set_volume(0.3)
    
    def run(self):
        pygame.mixer.music.play(-1)  # Boucle infinie
        while self.actif:
            time.sleep(0.5)
    
    def pause(self):
        self.en_pause = True
        pygame.mixer.music.pause()
    
    def reprendre(self):
        self.en_pause = False
        pygame.mixer.music.unpause()
\end{lstlisting}

\paragraph{Thread Spawner Ennemis}
Fait appara√Ætre des ennemis p√©riodiquement avec difficult√© progressive :

\begin{lstlisting}[caption=Spawner avec difficulte adaptative]
class SpawnerThread(threading.Thread):
    def __init__(self, game_engine):
        super().__init__(daemon=True)
        self.game_engine = game_engine
        self.intervalle = 2.0  # secondes
        self.vitesse = 0.3
    
    def run(self):
        while not self.game_engine.jeu_termine:
            time.sleep(self.intervalle)
            self.game_engine.ajouter_ennemi(self.vitesse)
    
    def ajuster_difficulte(self, ennemis_detruits):
        # Augmenter vitesse et frequence
        niveau = 1 + (ennemis_detruits // 5)
        self.vitesse = min(2.0, 0.3 * 1.08 ** niveau)
        self.intervalle = max(0.8, 2.0 - niveau * 0.3)
\end{lstlisting}

\paragraph{Thread Spawner Bonus}
Fait appara√Ætre des bonus al√©atoirement avec probabilit√© :

\begin{lstlisting}[caption=Spawner de bonus aleatoire]
class BonusSpawnerThread(threading.Thread):
    def run(self):
        while not self.game_engine.jeu_termine:
            # Intervalle aleatoire 8-15 secondes
            temps = random.uniform(8.0, 15.0)
            time.sleep(temps)
            
            # 30% de chance d'apparition
            if random.random() < 0.3:
                self.game_engine.ajouter_bonus()
\end{lstlisting}

Ces threads d√©montrent la \textbf{programmation parall√®le} : plusieurs t√¢ches s'ex√©cutent simultan√©ment (musique, spawn ennemis, spawn bonus, boucle principale), am√©liorant la fluidit√© et la r√©activit√© du jeu.

\section{Gestion des Scores}

\subsection{Format de sauvegarde JSON}

Les scores sont sauvegard√©s avec un historique complet et des statistiques d√©taill√©es :

\begin{lstlisting}[language=json,caption=Format JSON des scores avec historique]
{
  "Alice": {
    "meilleur_score": 230,
    "parties_jouees": 12,
    "score_total": 1850,
    "historique": [
      {"score": 180, "date": "2026-02-08 14:30:25"},
      {"score": 230, "date": "2026-02-08 15:12:10"},
      ...
    ]
  },
  "Bob": {
    "meilleur_score": 180,
    "parties_jouees": 5,
    "score_total": 750,
    "historique": [...]
  }
}
\end{lstlisting}

\subsection{Classe ScoreManager}

La classe \texttt{ScoreManager} g√®re toutes les op√©rations sur les scores avec fonctionnalit√©s avanc√©es :

\begin{itemize}
    \item \textbf{Chargement} : Lecture du fichier JSON au d√©marrage avec gestion d'erreurs
    \item \textbf{Sauvegarde} : √âcriture automatique apr√®s chaque partie
    \item \textbf{Enregistrement} : Mise √† jour du meilleur score et de l'historique
    \item \textbf{Historique} : Conservation des 10 derni√®res parties
    \item \textbf{Statistiques} : Calcul du score moyen, total, nombre de parties
    \item \textbf{Classement} : Tri des scores par ordre d√©croissant
    \item \textbf{Export HTML} : G√©n√©ration d'une page web interactive
\end{itemize}

\begin{lstlisting}[caption=M√©thode d'enregistrement avec historique]
def enregistrer_score(self, joueur: str, score: int) -> bool:
    ancien_record = self.obtenir_meilleur_score(joueur)
    nouveau_record = score > ancien_record
    
    if joueur not in self.scores:
        self.scores[joueur] = {
            "meilleur_score": 0,
            "parties_jouees": 0,
            "score_total": 0,
            "historique": []
        }
    
    # Mettre a jour les statistiques
    self.scores[joueur]["parties_jouees"] += 1
    self.scores[joueur]["score_total"] += score
    
    if score > self.scores[joueur]["meilleur_score"]:
        self.scores[joueur]["meilleur_score"] = score
    
    # Ajouter a l'historique avec timestamp
    self.scores[joueur]["historique"].append({
        "score": score,
        "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    })
    
    # Garder seulement les 10 dernieres parties
    if len(self.scores[joueur]["historique"]) > 10:
        self.scores[joueur]["historique"] = \
            self.scores[joueur]["historique"][-10:]
    
    self._sauvegarder_scores()
    return nouveau_record
\end{lstlisting}

\section{Interface Graphique}

\subsection{Choix technologique : tkinter}

La biblioth√®que \texttt{tkinter} a √©t√© choisie car :
\begin{itemize}
    \item Elle est incluse dans Python (pas de d√©pendance externe)
    \item Elle permet la gestion d'√©v√©nements (clavier, souris, timers)
    \item Elle offre un canvas pour le dessin 2D
    \item Elle supporte le redimensionnement dynamique
\end{itemize}

\subsection{Architecture de l'interface}

L'interface graphique est organis√©e en plusieurs √©crans :

\paragraph{Menu Principal (MenuPrincipal)}
\begin{itemize}
    \item Fond anim√© avec √©toiles d√©filantes
    \item Boutons : Jouer, Instructions, Scores, Quitter
    \item Titre avec effet de glow anim√©
    \item Responsive : adaptation automatique √† la taille d'√©cran
\end{itemize}

\paragraph{√âcran Instructions}
\begin{itemize}
    \item Explications des contr√¥les et m√©caniques
    \item Liste des bonus avec leurs effets
    \item Scrollable pour petit √©cran
\end{itemize}

\paragraph{√âcran Scores}
\begin{itemize}
    \item Affichage du classement des 10 meilleurs joueurs
    \item M√©dailles pour le top 3 (ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ)
    \item Bouton pour ouvrir le leaderboard web
    \item Couleurs diff√©renci√©es par rang
\end{itemize}

\paragraph{√âcran de Jeu}
\begin{itemize}
    \item Canvas principal avec fond spatial anim√©
    \item Affichage en temps r√©el : score, vies, temps, niveau
    \item Indicateurs de bonus actifs avec couleurs
    \item Support du redimensionnement en plein √©cran
    \item Contr√¥les musique (pause, volume)
\end{itemize}

\subsection{Gestion des √©v√©nements}

L'interface graphique r√©agit √† plusieurs types d'√©v√©nements :

\begin{itemize}
    \item \textbf{√âv√©nements clavier} : Fl√®ches directionnelles (‚Üê ‚Üí ‚Üë ‚Üì), ESPACE, P (pause musique), ESC (quitter)
    \item \textbf{√âv√©nements bouton} : Clics sur les boutons du menu
    \item \textbf{√âv√©nements timer} : Mise √† jour p√©riodique (30-50ms), spawn d'ennemis, spawn de bonus
    \item \textbf{√âv√©nements redimensionnement} : Adaptation dynamique des dimensions du jeu
\end{itemize}

\begin{lstlisting}[caption=Gestion du redimensionnement dynamique]
def sur_redimensionnement(self, event):
    if event.widget != self.root:
        return
    
    nouvelle_largeur = event.width
    nouvelle_hauteur = event.height
    
    # Mise a jour des dimensions
    self.LARGEUR_PIXELS = nouvelle_largeur
    self.HAUTEUR_PIXELS = nouvelle_hauteur
    
    # Ajuster les dimensions du moteur de jeu
    nouvelle_largeur_jeu = self.LARGEUR_PIXELS // self.TAILLE_CASE
    nouvelle_hauteur_jeu = self.HAUTEUR_JEU // self.TAILLE_CASE
    
    # Ajuster position du vaisseau proportionnellement
    ratio_x = nouvelle_largeur_jeu / self.game_engine.largeur
    self.game_engine.vaisseau.x *= ratio_x
    
    # Mettre a jour les dimensions
    self.game_engine.largeur = nouvelle_largeur_jeu
    self.game_engine.hauteur = nouvelle_hauteur_jeu
\end{lstlisting}

\subsection{Boucle de rendu}

Le jeu utilise une boucle de rendu asynchrone via \texttt{root.after()} :

\begin{lstlisting}[caption=Boucle de rendu graphique optimisee]
def boucle_mise_a_jour(self):
    if not self.jeu_en_cours:
        return
    
    # Mise a jour logique
    self.game_engine.mettre_a_jour()
    
    # Rendu graphique
    self.dessiner_fond_anime()
    self.dessiner_objets()
    self.dessiner_interface()
    
    # Relancer dans 30-50ms selon la performance
    self.root.after(30, self.boucle_mise_a_jour)

def dessiner_objets(self):
    # Dessiner bonus
    for bonus in self.game_engine.bonus:
        couleur = bonus.info["couleur"]
        self.canvas.create_oval(...)
    
    # Dessiner ennemis
    for ennemi in self.game_engine.ennemis:
        self.canvas.create_oval(..., fill='red')
    
    # Dessiner projectiles
    for proj in self.game_engine.projectiles:
        self.canvas.create_line(..., fill='yellow')
    
    # Dessiner vaisseau avec effet invincibilite
    if self.game_engine.vaisseau.invincible:
        # Clignotement
        couleur = 'yellow' if frame % 4 < 2 else 'cyan'
    else:
        couleur = self.couleur_vaisseau_selon_bonus()
    self.canvas.create_polygon(..., fill=couleur)
\end{lstlisting}

\section{Site Web de Scores}

\subsection{Architecture du site}

Le site web est une application \textbf{Single Page Application (SPA)} compos√©e de :
\begin{itemize}
    \item \texttt{index.html} : Structure HTML, styles CSS et JavaScript embarqu√©
    \item \texttt{scores.json} : Donn√©es charg√©es dynamiquement
    \item \texttt{serveur\_web.py} : Serveur HTTP local optionnel
\end{itemize}

\subsection{Serveur HTTP Local}

Un serveur HTTP simple permet de visualiser le leaderboard dans un navigateur :

\begin{lstlisting}[caption=Serveur HTTP avec auto-ouverture]
def demarrer_serveur():
    PORT = 8000
    handler = http.server.SimpleHTTPRequestHandler
    
    with socketserver.TCPServer(("", PORT), handler) as httpd:
        url = f"http://localhost:{PORT}/index.html"
        print(f"Serveur sur {url}")
        
        # Ouvrir automatiquement le navigateur
        webbrowser.open(url)
        
        # Demarrer
        httpd.serve_forever()
\end{lstlisting}

\subsection{Chargement des scores}

Le site utilise l'API \texttt{fetch()} pour charger le fichier JSON :

\begin{lstlisting}[language=html,caption=Chargement JavaScript des scores]
async function chargerScores() {
    const response = await fetch('scores.json');
    const data = await response.json();
    
    // Creer le tableau des scores
    let scoresArray = [];
    for (const [joueur, info] of Object.entries(data)) {
        scoresArray.push({
            joueur: joueur,
            score: info.meilleur_score,
            parties: info.parties_jouees,
            moyenne: (info.score_total / info.parties_jouees).toFixed(1)
        });
    }
    
    // Trier par score decroissant
    scoresArray.sort((a, b) => b.score - a.score);
    
    // Afficher dans le tableau HTML
    afficherTableau(scoresArray);
}
\end{lstlisting}

\subsection{Fonctionnalit√©s}

\begin{itemize}
    \item \textbf{Classement en temps r√©el} : Affichage des 20 meilleurs scores
    \item \textbf{M√©dailles} : Symboles sp√©ciaux pour les 3 premiers (ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ)
    \item \textbf{Design moderne} : Gradient de fond, animations, effets hover
    \item \textbf{Actualisation automatique} : Actualisation toutes les 30 secondes
    \item \textbf{Bouton refresh} : Actualisation manuelle
    \item \textbf{Responsive} : Adaptation mobile/tablette/desktop
    \item \textbf{Statistiques} : Score total, moyenne, derni√®re mise √† jour
\end{itemize}

\subsection{Export HTML automatique}

La m√©thode \texttt{exporter\_html()} du ScoreManager g√©n√®re automatiquement la page :

\begin{lstlisting}[caption=Generation HTML du leaderboard]
def exporter_html(self, fichier_sortie="index.html"):
    classement = self.obtenir_classement(20)
    
    html = """<!DOCTYPE html>
<html>
<head>
    <title>Shooter Spatial - Leaderboard</title>
    <style>
        /* Styles modernes avec gradients */
    </style>
</head>
<body>
    <h1>ÔøΩÔøΩ SHOOTER SPATIAL ÔøΩÔøΩ</h1>
"""
    
    for i, (joueur, score) in enumerate(classement, 1):
        medaille = "ÔøΩÔøΩ" if i == 1 else "ÔøΩÔøΩ" if i == 2 else "ÔøΩÔøΩ" if i == 3 else f"{i}."
        html += f'<div class="score-entry top{i if i <= 3 else ""}">'
        html += f'  <span>{medaille}</span>'
        html += f'  <span>{joueur}</span>'
        html += f'  <span>{score:,} pts</span>'
        html += '</div>'
    
    html += """
    <button onclick="location.reload()">ÔøΩÔøΩ Actualiser</button>
</body>
</html>
"""
    
    with open(fichier_sortie, 'w', encoding='utf-8') as f:
        f.write(html)
\end{lstlisting}

\section{Tests et Exemples d'Utilisation}

\subsection{Sc√©nario de test 1 : Partie rapide}

\begin{enumerate}
    \item Lancement du jeu (version GUI)
    \item Saisie du nom : "Alice"
    \item Destruction de 10 ennemis = 100 points
    \item Nouveau record enregistr√©
\end{enumerate}

\subsection{Sc√©nario de test 2 : D√©faite}

\begin{enumerate}
    \item Lancement du jeu
    \item Le joueur ne tire pas assez vite
    \item Un ennemi atteint le bas de l'√©cran
    \item D√©faite avec score de 30 points
    \item Score non enregistr√© (inf√©rieur au record)
\end{enumerate}

\section{Conclusion}

\subsection{Bilan du projet}

Ce projet a permis de mettre en pratique quatre paradigmes de programmation √©tudi√©s :

\begin{itemize}
    \item \textbf{POO} : Architecture claire avec h√©ritage (5 classes h√©ritant d'ObjetVolant), encapsulation des donn√©es et m√©thodes, polymorphisme sur les collisions
    \item \textbf{Proc√©dural} : Boucle de jeu lin√©aire en version console avec s√©quence d'instructions
    \item \textbf{√âv√©nementiel} : Interface graphique r√©active avec tkinter (clavier, boutons, timers), gestion d'√©v√©nements asynchrones
    \item \textbf{Concurrent} : Threads pour musique, spawn d'ennemis et spawn de bonus s'ex√©cutant en parall√®le
\end{itemize}

Le syst√®me de scores avec persistance JSON, historique d√©taill√© et le site web de leaderboard compl√®tent le projet en ajoutant des fonctionnalit√©s modernes et professionnelles.

\subsection{Fonctionnalit√©s impl√©ment√©es}

Le jeu inclut de nombreuses fonctionnalit√©s avanc√©es :

\begin{enumerate}
    \item \textbf{Syst√®me de bonus} : 5 types de bonus avec effets temporaires et pond√©ration de probabilit√©
    \item \textbf{Syst√®me de vies} : 3 √† 5 vies avec invincibilit√© temporaire apr√®s perte
    \item \textbf{Difficult√© progressive} : Vitesse et fr√©quence d'apparition augmentent avec le score
    \item \textbf{Interface moderne} : Menu anim√©, √©crans multiples, responsive design
    \item \textbf{Support multi-plateformes} : Version console (Windows/Linux/Mac) et GUI
    \item \textbf{Musique} : Support de musique de fond avec pause et contr√¥le du volume
    \item \textbf{Statistiques compl√®tes} : Historique des 10 derni√®res parties, score moyen
    \item \textbf{Leaderboard web} : Page HTML g√©n√©r√©e automatiquement avec design moderne
    \item \textbf{Plein √©cran adaptatif} : Redimensionnement dynamique pour maximiser l'exp√©rience
    \item \textbf{Adaptation de la difficult√©} : Vitesse du vaisseau adapt√©e √† la taille d'√©cran
\end{enumerate}

\subsection{Perspectives d'am√©lioration}

Plusieurs am√©liorations pourraient √™tre apport√©es dans le futur :

\begin{enumerate}
    \item \textbf{Nouveaux types d'ennemis} 
    \begin{itemize}
        \item Ennemis avec patterns de d√©placement diff√©rents (zigzag, cercles)
        \item Ennemis qui tirent des projectiles
        \item Boss de fin de niveau avec points de vie multiples
    \end{itemize}
    
    \item \textbf{Power-ups avanc√©s}
    \begin{itemize}
        \item Bouclier temporaire absorbant les d√©g√¢ts
        \item Ralentissement du temps
        \item Bombe d√©truisant tous les ennemis √† l'√©cran
        \item Aimant attirant tous les bonus
    \end{itemize}
    
    \item \textbf{Effets visuels et audio}
    \begin{itemize}
        \item Animations d'explosion avec particules
        \item Effets sonores pour tirs, collisions, bonus
        \item Musiques th√©matiques changeant selon le niveau
        \item Effet de secousse d'√©cran lors des impacts
    \end{itemize}
    
    \item \textbf{Modes de jeu additionnels}
    \begin{itemize}
        \item Mode survie : dur√©e illimit√©e, difficult√© croissante extr√™me
        \item Mode campagne : s√©rie de niveaux avec objectifs
        \item Mode contre-la-montre : atteindre un score en temps limit√©
        \item Mode zen : pas de mort, pour l'entra√Ænement
    \end{itemize}
    
    \item \textbf{Multijoueur}
    \begin{itemize}
        \item Mode coop√©ratif local (2 joueurs, clavier partag√©)
        \item Mode comp√©titif (qui survit le plus longtemps)
        \item Leaderboard en ligne avec API REST
        \item Synchronisation des scores entre machines
    \end{itemize}
    
    \item \textbf{Personnalisation}
    \begin{itemize}
        \item Choix du vaisseau (apparence, caract√©ristiques)
        \item Skins et th√®mes visuels (espace, oc√©an, cyberpunk)
        \item Syst√®me de progression et d√©blocage de contenus
        \item Achievements et troph√©es
    \end{itemize}
    
    \item \textbf{Optimisations techniques}
    \begin{itemize}
        \item Pool d'objets pour √©viter l'allocation m√©moire excessive
        \item Quadtree ou spatial hashing pour d√©tection de collisions optimis√©e
        \item Compilation avec Cython pour am√©liorer les performances
        \item Support de shaders avec OpenGL via PyOpenGL
    \end{itemize}
\end{enumerate}

\subsection{Comp√©tences acquises}

Ce projet a renforc√© :
\begin{itemize}
    \item La ma√Ætrise de Python et de ses biblioth√®ques standard (tkinter, threading, json, pathlib)
    \item La conception orient√©e objet et les diagrammes UML (classes, s√©quence, activit√©s)
    \item La gestion d'√©v√©nements dans les interfaces graphiques
    \item La programmation concurrente avec threads et synchronisation
    \item La manipulation de fichiers JSON pour la persistance
    \item Le d√©veloppement web frontend (HTML/CSS/JavaScript)
    \item La documentation technique avec \LaTeX\ et PlantUML
    \item L'architecture logicielle et la s√©paration des responsabilit√©s
    \item Le debugging et la gestion d'erreurs
    \item L'optimisation de performances (framerate, affichage)
\end{itemize}

\subsection{R√©flexion sur les paradigmes}

Ce projet d√©montre qu'aucun paradigme n'est sup√©rieur aux autres : chacun a ses forces et son domaine d'application optimal. La cl√© d'un bon logiciel est de savoir combiner judicieusement les paradigmes selon les besoins :

\begin{itemize}
    \item \textbf{POO} pour structurer le code et favoriser la r√©utilisation
    \item \textbf{Proc√©dural} pour les algorithmes s√©quentiels et la logique de jeu
    \item \textbf{√âv√©nementiel} pour les interfaces interactives et r√©actives
    \item \textbf{Concurrent} pour les t√¢ches parall√®les et l'am√©lioration des performances
\end{itemize}

Cette approche multi-paradigme est repr√©sentative du d√©veloppement logiciel moderne, o√π la flexibilit√© et l'adaptation aux probl√®mes sont essentielles.

\section*{Annexes}

\subsection*{A. Structure des fichiers}

\begin{verbatim}
shooter_spatial/
‚îÇ
‚îú‚îÄ‚îÄ game/                       # Module principal du jeu
‚îÇ   ‚îú‚îÄ‚îÄ game_classes.py         # Classes POO (ObjetVolant, Vaisseau, 
‚îÇ   ‚îÇ                           #   Ennemi, Projectile, Bonus, GameEngine)
‚îÇ   ‚îú‚îÄ‚îÄ score_manager.py        # Gestion scores avec historique
‚îÇ   ‚îú‚îÄ‚îÄ shooter_console.py      # Version console plein √©cran
‚îÇ   ‚îú‚îÄ‚îÄ shooter_gui.py          # Version GUI avec menu
‚îÇ   ‚îú‚îÄ‚îÄ serveur_web.py          # Serveur HTTP pour leaderboard
‚îÇ   ‚îú‚îÄ‚îÄ index.html              # Leaderboard web (g√©n√©r√©)
‚îÇ   ‚îî‚îÄ‚îÄ scores.json             # Donn√©es des scores
‚îÇ
‚îú‚îÄ‚îÄ shooter_console.bat         # Lanceur Windows (console)
‚îú‚îÄ‚îÄ shooter_gui.bat             # Lanceur Windows (GUI)
‚îú‚îÄ‚îÄ installer_dependencies.bat  # Installation automatique
‚îÇ
‚îú‚îÄ‚îÄ diagramme.puml              # Diagrammes UML (PlantUML)
‚îú‚îÄ‚îÄ rapport.tex                 # Ce rapport (LaTeX)
‚îú‚îÄ‚îÄ README.md                   # Documentation utilisateur
\end{verbatim}

\subsection*{B. Commandes d'ex√©cution}

\paragraph{Installation des d√©pendances}
\begin{verbatim}
# Windows (recommand√©) :
installer_dependencies.bat

# Ou manuellement :
pip install pygame
\end{verbatim}

\paragraph{Version console}
\begin{verbatim}
python game/shooter_console.py
# ou double-clic sur shooter_console.bat (Windows)
\end{verbatim}

\paragraph{Version graphique (recommand√©)}
\begin{verbatim}
python game/shooter_gui.py
# ou double-clic sur shooter_gui.bat (Windows)
\end{verbatim}

\paragraph{Serveur web pour leaderboard}
\begin{verbatim}
python game/serveur_web.py
# Ouvre automatiquement http://localhost:8000/index.html
\end{verbatim}

\subsection*{C. Configuration et personnalisation}

\paragraph{Difficult√© (dans shooter\_console.py et shooter\_gui.py)}
\begin{verbatim}
class ConfigDifficulte:
    VITESSE_INITIALE = 0.3    # Vitesse des ennemis
    SPAWN_INITIAL = 2.0        # Intervalle spawn (secondes)
    CHANCE_BONUS = 0.3         # Probabilit√© d'apparition bonus
    VIES_DEPART = 3            # Nombre de vies initial
\end{verbatim}

\paragraph{Volume de la musique}
\begin{verbatim}
# Dans le constructeur de MusiqueThread
pygame.mixer.music.set_volume(0.3)  # 0.0 √† 1.0
\end{verbatim}

\paragraph{Dimensions de la fen√™tre GUI}
\begin{verbatim}
# Adaptation automatique √† l'√©cran
# Peut √™tre modifi√© dans shooter_gui.py ligne ~25
largeur = 600  # Minimum
hauteur = 800  # Minimum
\end{verbatim}

\end{document}